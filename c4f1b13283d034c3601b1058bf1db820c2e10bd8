{
  "comments": [
    {
      "key": {
        "uuid": "8bc6f397_faf71a8b",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3628,
      "author": {
        "id": 1014954
      },
      "writtenOn": "2019-11-15T06:16:11Z",
      "side": 1,
      "message": "WARNING: line over 80 characters\n+\t\tfprintf(stderr, \"%s: offset (%ld) is too large (upper: %ld, lower: %ld)\\n\",",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2fc42a07_3d2cbdf9",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3646,
      "author": {
        "id": 1014954
      },
      "writtenOn": "2019-11-15T06:16:11Z",
      "side": 1,
      "message": "WARNING: line over 80 characters\n+\t__dprintf(\"mck_dirents_size: %ld, offset: %ld, mck_len: %d, count: %d\\n\",",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8e37b011_315f63c8",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3653,
      "author": {
        "id": 1014954
      },
      "writtenOn": "2019-11-15T06:16:11Z",
      "side": 1,
      "message": "WARNING: line over 80 characters\n+\t\t__dprintf(\"linux_dirents_size: %ld, offset: %ld, linux_len: %d, count: %d\\n\",",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a454ea75_fab7579e",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3663,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2019-11-15T06:25:10Z",
      "side": 1,
      "message": "I believe this should be `offset + pos + reclen` ?",
      "range": {
        "startLine": 3663,
        "startChar": 38,
        "endLine": 3663,
        "endChar": 50
      },
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f431d5a_6a7ee6a6",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3663,
      "author": {
        "id": 1014590
      },
      "writtenOn": "2019-11-15T07:28:20Z",
      "side": 1,
      "message": "That\u0027s right.\n\nI moved the d_off fix to the location where editiing linux_dirp as you suggested because I found there\u0027s no need to fix the mck_dirp (the last entry points to the end of mck_dirp).\n\n... but I found that d_off fields aren\u0027t filled on ofp machine.\nSo I added the code to fill d_off for mck_dirp as well.",
      "parentUuid": "a454ea75_fab7579e",
      "range": {
        "startLine": 3663,
        "startChar": 38,
        "endLine": 3663,
        "endChar": 50
      },
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6af0fe69_23d163fc",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3667,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2019-11-15T06:26:40Z",
      "side": 1,
      "message": "actually same for the lseek, a directory read into three getdents would probably loop forever?",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ed3728b_ca14ee9f",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3667,
      "author": {
        "id": 1014590
      },
      "writtenOn": "2019-11-15T07:28:20Z",
      "side": 1,
      "message": "you mean lseek itself refers to d_off?",
      "parentUuid": "6af0fe69_23d163fc",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a496038_04609239",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3667,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2019-11-15T09:29:41Z",
      "side": 1,
      "message": "I believe the whole point of d_off is to use as an argument to lseek, yes. But I was wrong with my previous remark, I thought this was a SEEK_SET, so with SEEK_CUR you are correct with this code -- I was still assuming the initial mckernel getdents were done on fd but they are on a specific fd so it should work.\n\nIf you have time please try this program (mostly the example from `man 2 getdents`, with a lseek(fd, 0, SEEK_CUR) between getdents) : it should always print the same offset in lseek and in the last d_off of the chunk.\n\n    // test getdents d_off and lseek are coherent\n#define _GNU_SOURCE\n#include \u003cdirent.h\u003e     /* Defines DT_* constants */\n#include \u003cfcntl.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003cunistd.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003csys/stat.h\u003e\n#include \u003csys/syscall.h\u003e\n\n#define handle_error(msg) \\\n        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n\nstruct linux_dirent {\n    long           d_ino;\n    off_t          d_off;\n    unsigned short d_reclen;\n    char           d_name[];\n};\n\n#define BUF_SIZE 200\n\nint\nmain(int argc, char *argv[])\n{\n    int fd, nread;\n    char buf[BUF_SIZE];\n    struct linux_dirent *d;\n    int bpos;\n    char d_type;\n\n    fd \u003d open(argc \u003e 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n    if (fd \u003d\u003d -1)\n        handle_error(\"open\");\n\n    for ( ; ; ) {\n        nread \u003d syscall(SYS_getdents, fd, buf, BUF_SIZE);\n        if (nread \u003d\u003d -1)\n            handle_error(\"getdents\");\n\n        if (nread \u003d\u003d 0)\n            break;\n\n        printf(\"--------------- nread\u003d%d ---------------\\n\", nread);\n        printf(\"i-node#  file type  d_reclen  d_off   d_name\\n\");\n        for (bpos \u003d 0; bpos \u003c nread;) {\n            d \u003d (struct linux_dirent *) (buf + bpos);\n            printf(\"%8ld  \", d-\u003ed_ino);\n            d_type \u003d *(buf + bpos + d-\u003ed_reclen - 1);\n            printf(\"%-10s \", (d_type \u003d\u003d DT_REG) ?  \"regular\" :\n                             (d_type \u003d\u003d DT_DIR) ?  \"directory\" :\n                             (d_type \u003d\u003d DT_FIFO) ? \"FIFO\" :\n                             (d_type \u003d\u003d DT_SOCK) ? \"socket\" :\n                             (d_type \u003d\u003d DT_LNK) ?  \"symlink\" :\n                             (d_type \u003d\u003d DT_BLK) ?  \"block dev\" :\n                             (d_type \u003d\u003d DT_CHR) ?  \"char dev\" : \"???\");\n            printf(\"%4d %10lld  %s\\n\", d-\u003ed_reclen,\n                    (long long) d-\u003ed_off, (char *) d-\u003ed_name);\n            bpos +\u003d d-\u003ed_reclen;\n        }\n\tprintf(\"at end of getdents: lseek %10lld\\n\", lseek(fd, 0, SEEK_CUR));\n    }\n\n    exit(EXIT_SUCCESS);\n}",
      "parentUuid": "2ed3728b_ca14ee9f",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dd4a5ae_66092453",
        "filename": "executer/user/mcexec.c",
        "patchSetId": 5
      },
      "lineNbr": 3667,
      "author": {
        "id": 1014590
      },
      "writtenOn": "2019-11-17T13:26:24Z",
      "side": 1,
      "message": "okay, I added the test program and checked the result looks correct.",
      "parentUuid": "4a496038_04609239",
      "revId": "c4f1b13283d034c3601b1058bf1db820c2e10bd8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}