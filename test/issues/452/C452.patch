diff --git a/arch/arm64/kernel/include/syscall_list.h b/arch/arm64/kernel/include/syscall_list.h
index f911674..52c164f 100644
--- a/arch/arm64/kernel/include/syscall_list.h
+++ b/arch/arm64/kernel/include/syscall_list.h
@@ -134,6 +134,8 @@ SYSCALL_HANDLED(731, util_indicate_clone)
 SYSCALL_HANDLED(732, get_system)
 SYSCALL_HANDLED(733, util_register_desc)
 
+SYSCALL_HANDLED(740, setkdebug)
+
 /* McKernel Specific */
 SYSCALL_HANDLED(801, swapout)
 SYSCALL_HANDLED(802, linux_mlock)
diff --git a/arch/x86_64/kernel/include/syscall_list.h b/arch/x86_64/kernel/include/syscall_list.h
index 79eda7f..1f81b0a 100644
--- a/arch/x86_64/kernel/include/syscall_list.h
+++ b/arch/x86_64/kernel/include/syscall_list.h
@@ -174,6 +174,8 @@ SYSCALL_HANDLED(731, util_indicate_clone)
 SYSCALL_HANDLED(732, get_system)
 SYSCALL_HANDLED(733, util_register_desc)
 
+SYSCALL_HANDLED(740, setkdebug)
+
 /* McKernel Specific */
 SYSCALL_HANDLED(801, swapout)
 SYSCALL_HANDLED(802, linux_mlock)
diff --git a/kernel/include/process.h b/kernel/include/process.h
index 0a9ff47..ecb464f 100644
--- a/kernel/include/process.h
+++ b/kernel/include/process.h
@@ -573,6 +573,7 @@ struct process {
 #endif // PROFILE_ENABLE
 	int nr_processes; /* For partitioned execution */
 	int process_rank; /* Rank in partition */
+	int debug_flags;
 };
 
 /*
diff --git a/kernel/procfs.c b/kernel/procfs.c
index 5f9675c..a1b6d22 100644
--- a/kernel/procfs.c
+++ b/kernel/procfs.c
@@ -420,6 +420,7 @@ int process_procfs_request(struct ikc_scd_packet *rpacket)
 	if (strcmp(p, "maps") == 0) {
 		struct vm_range *range;
 
+		kprintf("read /proc/*/maps\n");
 		memory_range_read_lock(vm, &irqflags);
 
 		range = lookup_process_memory_range(vm, 0, -1);
@@ -485,6 +486,7 @@ int process_procfs_request(struct ikc_scd_packet *rpacket)
 		start = (offset / sizeof(uint64_t)) << PAGE_SHIFT;
 		end = start + ((count / sizeof(uint64_t)) << PAGE_SHIFT);
 		
+		kprintf("read /proc/*/pagemap\n");
 		memory_range_read_lock(vm, &irqflags);
 
 		while (start < end) {
@@ -527,6 +529,7 @@ int process_procfs_request(struct ikc_scd_packet *rpacket)
 			goto err;
 		}
 
+		kprintf("read /proc/*/status\n");
 		memory_range_read_lock(proc->vm, &irqflags);
 		range = lookup_process_memory_range(vm, 0, -1);
 		while (range) {
diff --git a/kernel/syscall.c b/kernel/syscall.c
index 012ef13..9a34984 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -1635,6 +1635,18 @@ do_mmap(const uintptr_t addr0, const size_t len0, const int prot,
 	flush_nfo_tlb();
 
 	memory_range_write_lock(thread->vm, &irqflags);
+	if(thread->proc->debug_flags) {
+		// sleep 5 sec
+		unsigned long ts = rdtsc();
+		unsigned long nanosecs = 5000000000L;
+		unsigned long tscs = nanosecs * 1000 / ihk_mc_get_ns_per_tsc();
+
+		kprintf("kernel debug sleep 5sec...\n");
+		while (rdtsc() - ts < tscs) {
+			cpu_pause();
+		}
+		kprintf("kernel debug wake up\n");
+	}
 
 	if (flags & MAP_HUGETLB) {
 		pgshift = (flags >> MAP_HUGE_SHIFT) & 0x3F;
@@ -9482,6 +9494,17 @@ SYSCALL_DECLARE(util_register_desc)
 	return 0;
 }
 
+SYSCALL_DECLARE(setkdebug)
+{
+	int flags = ihk_mc_syscall_arg0(ctx);
+	struct thread *mythread = cpu_local_var(current);
+	struct process *proc = mythread->proc;
+
+	kprintf("set kernel debug flag pid=%d val=%d\n", proc->pid, flags);
+	proc->debug_flags = flags;
+	return 0;
+}
+
 void
 reset_cputime()
 {
